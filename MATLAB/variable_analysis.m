%% Submission status
% Submitted for review - TM Louw

%% Non-Linear Data Reconciliation
% This main function loads the true data generated by the model of
% the binary distillation column. It then performs non-linear data reconciliation on the corrupted
% 'measurements', for both AVM & SVM. Lastly, it evaluates the
% effectiveness of non-linear DR and the effect of reducing the amount of
% measurements.  

% Key:
% AVM - All Variables Measured 
% SVM - Some Variables Measured
% MAPE - Mean Absolute Percentage Error

%% Initialise
clear
clc

%% Load data
load('true_data', 'measured_dataFlow', 'measured_dataMole', 'MM', 'X', 'tSol', 'true_data', 'v', 'u', 'p', 'variance', 'time')

%% Specifications & bounds
a          = 5;                       % Amout of loop iterations               
upperBound = [Inf(7,1); ones(6,1)];   % Upper bounds - flowrates can technically be infinite whilst fractions can be a maximum of 1
lowerBound = zeros(13,1);             % Lower bounds - flowrates and fractions can't be lower than zero

% Pre-allocation
Xhat = zeros(13,1001);
XB   = zeros(a,1001);

%% Observability analysis
for i = 1:a
    % Set Up Matrices
    v = i-1;            % Function specification (used in measurements_Y to specify measured variables) 
    X0 = zeros(13,1);   % Initial guesses for each loop
    [Y, index, W] = measurements_Y(v, measured_dataFlow, measured_dataMole, variance); % Generates measurement & variance matrix structures

    for j = 1:length(time)
        % Weighted objective function given current measurements Y(:,i)

        J = @(x) (Y(:,j) - x(index))'*W*(Y(:,j) - x(index));

        % Non-linear constraints f(x) = 0. See the bottom of the script
        % Find the non-linear estimates. Use the measurements as initial guess
        % See the help file for fmincon to understand the different required input arguments.
        Xhat(:,j) = fmincon(J, X0,[],[],[],[],lowerBound, upperBound, @nonLinearConstraints);  % Reconciled values for each variable
        X0(index) = Y(:,j);                                                                    % New guesses
    end

    XB(i,:) = Xhat(9,:);  % XB reconciled values for each loop (each degree of redundancy)
    LB(i,:) = Xhat(2,:);  % LB reconciled values for each loop (each degree of redundancy)

end



%% Error Metrics
% Mean Absolute Percentage Error - XB
mapeM    = mean(100*abs((true_data.XB(:,100:end) - measured_dataMole.XB(:,100:end))./true_data.XB(:,100:end)));
mape_avm = mean(100*abs((true_data.XB(:,100:end) - XB(1,100:end))./true_data.XB(:,100:end)));

% Mean Absolute Percentage Error - LB
mapeM1    = mean(100*abs((true_data.LB(:,100:end) - measured_dataFlow.LB(:,100:end))./true_data.LB(:,100:end)));
mape_avm1 = mean(100*abs((true_data.LB(:,100:end) - LB(1,100:end))./true_data.LB(:,100:end)));

% Residuals - XB
resM    = true_data.XB - measured_dataMole.XB;
res_avm = true_data.XB - XB(1,:);
meanM    = mean(resM); varM = var(resM);
mean_avm = mean(res_avm); var_avm = var(res_avm); 

% Residuals - LB
resM1    = true_data.LB - measured_dataFlow.LB;
res_avm1 = true_data.LB - LB(1,:);

% Probability distributuions - XB
[fm, xim]     = ksdensity(resM(:,100:end));
[favm, xiavm] = ksdensity(res_avm(:,100:end));

% Probability distributuions - LB
[fm1, xim1]     = ksdensity(resM1(:,100:end));
[favm1, xiavm1] = ksdensity(res_avm1(:,100:end));

% Preallocate
mape_svm = zeros(a-1,1); mape_svm1 = zeros(a-1,1);
res_svm = zeros(a-1,1001); res_svm1 = zeros(a-1,1001);
fsvm = zeros(a-1,100); fsvm1 = zeros(a-1,100); 
xisvm = zeros(a-1,100); xisvm1 = zeros(a-1,100);
mean_svm = zeros(a-1,1); var_svm = zeros(a-1,1);
for i = 1:a-1
    % XB
    mape_svm(i) = mean(100*abs((true_data.XB(:,100:end) - XB(i+1,100:end))./true_data.XB(:,100:end)));
    res_svm(i,:) = true_data.XB - XB(i+1,:);
    [fsvm(i,:), xisvm(i,:)] = ksdensity(res_svm(i,100:end));
    mean_svm(i,1) = mean(res_svm(i,:)); var_svm(i,1) = var(res_svm(i,:));
    
    % LB
    mape_svm1(i) = mean(100*abs((true_data.LB(:,100:end) - LB(i+1,100:end))./true_data.LB(:,100:end)));
    res_svm1(i,:) = true_data.LB - LB(i+1,:);
    [fsvm1(i,:), xisvm1(i,:)] = ksdensity(res_svm1(i,100:end));
end

%% Display results
disp = 1;

if disp == 1
    plot(xim, fm, 'k', xiavm, favm, 'r')
    hold on
    xlabel("Residual Value"); ylabel("Probability")
    xlim([-0.15 0.15]);
    for i = 1:a-1
        if i == 1
            plot(xisvm(i,:), fsvm(i,:), 'b')
        elseif i == 2
            plot(xisvm(i,:), fsvm(i,:), 'g')
        elseif i == 3
            plot(xisvm(i,:), fsvm(i,:), 'c')
        elseif i == 4
            plot(xisvm(i,:), fsvm(i,:), 'm')
        end
    end 
    legend("Measurement: MAPE = "+num2str(mapeM)+"%", "DR - AVM: MAPE = "+num2str(mape_avm)+"%",...
           "DR - XF removed: MAPE = "+num2str(mape_svm(1))+"%", "DR - X1 removed: MAPE = "+num2str(mape_svm(2))+"%",...
           "DR - XD removed: MAPE = "+num2str(mape_svm(3))+"%", "DR - Y4 removed: MAPE = "+num2str(mape_svm(4))+"%", 'Location', 'Best')
    sgtitle("Non-Linear Probability distributions - Variable influence on redundancy")
    hold off
    
else
    plot(xim1, fm1, 'k', xiavm1, favm1, 'r')
    hold on
    xlabel("Residual Value"); ylabel("Probability")
    %xlim([-1.5 1.5]);
    for i = 1:a-1
        if i == 1
            plot(xisvm1(i,:), fsvm1(i,:), 'b')
        elseif i == 2
            plot(xisvm1(i,:), fsvm1(i,:), 'g')
        elseif i == 3
            plot(xisvm1(i,:), fsvm1(i,:), 'c')
        elseif i == 4
            plot(xisvm1(i,:), fsvm1(i,:), 'm')
        end
    end
    legend("Measurement: MAPE = "+num2str(mapeM1)+"%", "DR - AVM: MAPE = "+num2str(mape_avm1)+"%",...
           "DR - LF removed: MAPE = "+num2str(mape_svm1(1))+"%", "DR - L1 removed: MAPE = "+num2str(mape_svm1(2))+"%",...
           "DR - LD removed: MAPE = "+num2str(mape_svm1(3))+"%", "DR - V4 removed: MAPE = "+num2str(mape_svm1(4))+"%", 'Location', 'Best')
    sgtitle("Non-Linear Probability distributions - Variable influence on redundancy")
    hold off 

end




%% Function
function [g, f] = nonLinearConstraints(x)
    g = []; % No inequality constraints
    % Mass balances
    % x(1) = L1; x(2) = LB; x(3) = LD; x(4) = LR; x(5) = V0; x(6) = V4; 
    % x(7) = LF; x(8) = X1; x(9) = XB; x(10) = XD; x(11) = Y0; x(12) = Y4;
    % x(13) = XF
    f = [x(7) - x(3) - x(2);...
         x(1) - x(2) - x(5);...
         x(6) - x(3) - x(4);...
         x(7)*x(13) - x(3)*x(10) - x(2)*x(9);...
         x(1)*x(8)  - x(2)*x(9)  - x(5)*x(11);...
         x(6)*x(12) - x(3)*x(10) - x(4)*x(10)];
end

%% Function
function [Y, index, W] = measurements_Y(v, measured_dataFlow, measured_dataMole, variance)
    if v == 0 % All variables measured
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF; measured_dataMole.X1;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0; measured_dataMole.Y4;...
             measured_dataMole.XF];
        index = [1:13]; 
        W = diag([ones(7,1)*variance.^2; ones(6,1)*(variance.^2)/10]);
        
    elseif v == 1 % Remove XF
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF; measured_dataMole.X1;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0; measured_dataMole.Y4];
        index = [1:12]; 
        W = diag([ones(7,1)*variance.^2; ones(5,1)*(variance.^2)/10]);
        
    elseif v == 2 % Remove X1
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0; measured_dataMole.Y4;...
             measured_dataMole.XF];
        index = [1:7,9:13]; 
        W = diag([ones(7,1)*variance.^2; ones(5,1)*(variance.^2)/10]);

    elseif v == 3 % Remove XD
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF; measured_dataMole.X1;...
             measured_dataMole.XB; measured_dataMole.Y0; measured_dataMole.Y4;...
             measured_dataMole.XF];
        index = [1:9,11:13]; 
        W = diag([ones(7,1)*variance.^2; ones(5,1)*(variance.^2)/10]);      
                
    elseif v == 4 % Remove Y4
        Y = [measured_dataFlow.L1; measured_dataFlow.LB; measured_dataFlow.LD; measured_dataFlow.LR;...
             measured_dataFlow.V0; measured_dataFlow.V4; measured_dataFlow.LF; measured_dataMole.X1;...
             measured_dataMole.XB; measured_dataMole.XD; measured_dataMole.Y0;...
             measured_dataMole.XF];
        index = [1:11,13]; 
        W = diag([ones(7,1)*variance.^2; ones(5,1)*(variance.^2)/10]);        
    end  
    
end